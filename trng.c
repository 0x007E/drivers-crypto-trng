/**
 * @file trng.c
 *
 * @brief Implementation of the True Random Number Generator (TRNG) functions.
 *
 * This file contains the implementation of the TRNG driver functions used to initialize, reset, and manage a True Random Number Generator. It processes entropy bits using a Von Neumann correction algorithm and stores the resulting random data in an internal buffer for later retrieval.
 *
 * The library is intended for embedded systems requiring nondeterministic random data, such as cryptographic applications, seeding pseudorandom generators, or generating unique identifiers.
 *
 * @author g.raf
 * @date 2026-01-27
 * @version 1.0 Release
 * @copyright
 * Copyright (c) 2026 g.raf
 * Released under the GPLv3 License. (see LICENSE in repository)
 * 
 * @note This file is part of a larger embedded project and is subject to the license specified in the repository. For updates and the complete revision history, see the project's GitHub repository.
 *
 * @see https://github.com/0x007e/driver-crypto-trng "TRNG driver library"
 */

#include "trng.h"

volatile unsigned char buffer[TRNG_BUFFER_SIZE];
volatile unsigned char current_buffer_position;
volatile unsigned char current_buffer_bit_position;

/**
 * @brief Initializes the True Random Number Generator (TRNG) module.
 *
 * @details
 * This function prepares the TRNG module for operation by resetting its internal state and buffer. It should be called once during system initialization before feeding entropy bits using @ref trng_next_bit(). Internally, this function calls @ref trng_reset() to clear all buffer data and reset counters.
 *
 * @note Must be called before any random data collection begins.
 *
 * @see trng_reset(), trng_next_bit(), trng_buffer_status()
 */
void trng_init(void)
{
	trng_reset();
}

volatile unsigned char  first_bit;
volatile unsigned char last_bit;
volatile unsigned char  primary_run;

/**
 * @brief Processes a single entropy bit and adds it to the TRNG buffer.
 *
 * @details
 * This function is called repeatedly with raw entropy bits obtained from a hardware or software noise source. It applies the Von Neumann correction algorithm to remove bias from the input bit sequence and produces unbiased random bits. The corrected bits are packed into the internal TRNG buffer until it reaches the configured size defined by @ref TRNG_BUFFER_SIZE. Once the buffer is full, no further bits are stored until it is reset.
 *
 * @param bit The next raw entropy bit to process (must be 0 or 1).
 *
 * @note
 * - The function performs no operation if the buffer is already full.
 * - Each call expects a single bit input, not a byte or word.
 * - This function internally manages bit-packing and buffer indexing.
 *
 * @see trng_init(), trng_reset(), trng_buffer(), trng_buffer_status()
 */
void trng_next_bit(unsigned char bit)
{	
	if(current_buffer_position >= TRNG_BUFFER_SIZE)
	{
		return;
	}
	
	// Von-Neumann-Correction
	unsigned char out_bit = 0;

	if (!primary_run)
	{
		first_bit  = bit;
		primary_run = 1;
		return;
	}
	primary_run = 0;

	if (first_bit != bit)
	{
		out_bit = 0;
		
		if(first_bit != 0 && bit == 0)
		{
			out_bit = 1;
		}
	}
	else
	{
		return;
	}
	
	if(out_bit > 0)
	{
		buffer[current_buffer_position]	|= (1<<current_buffer_bit_position);
	}
	current_buffer_bit_position++;
	
	if(current_buffer_bit_position >= 8)
	{
		current_buffer_position++;
		current_buffer_bit_position = 0;
	}
}

/**
 * @brief Returns the current fill status of the TRNG buffer.
 *
 * @details
 * This function checks the internal TRNG buffer and reports whether it is empty, partially filled, or completely full. It uses internal position counters to determine the current state of the random data storage.
 *
 * The return value can be one of the following:
 * - @ref TRNG_Buffer_Empty — no random bits have been stored yet
 * - @ref TRNG_Buffer_Filling — the buffer is currently being filled
 * - @ref TRNG_Buffer_Full — the buffer is full and ready for readout or reset
 *
 * @return TRNG_Buffer: The current buffer status as a value from the @ref TRNG_Buffer enumeration.
 *
 * @note This function allows external code to determine when new random data can be read or when the buffer should be reset.
 *
 * @see trng_buffer(), trng_reset(), trng_next_bit()
 */
TRNG_Buffer trng_buffer_status(void)
{
	if( (current_buffer_position == 0UL) &&
		(current_buffer_bit_position == 0UL))
	{
		return TRNG_Buffer_Empty;
	}
	else if(current_buffer_position >= TRNG_BUFFER_SIZE)
	{
		return TRNG_Buffer_Full;
	}
	return TRNG_Buffer_Filling;
}

/**
 * @brief Returns a pointer to the internal TRNG buffer.
 *
 * @details
 * This function provides direct access to the internal memory buffer that stores the corrected random bytes generated by the True Random Number Generator (TRNG). The buffer can be read once the buffer status, retrieved by @ref trng_buffer_status(), indicates that it is full.
 *
 * @return volatile unsigned char*: Pointer to the internal TRNG buffer containing random data.
 *
 * @note
 * - The returned pointer references volatile memory, as the buffer content
 *   may be modified by ongoing TRNG operations.
 * - Ensure that the buffer is not read while still filling to avoid
 *   inconsistent data.
 *
 * @see trng_buffer_status(), trng_reset()
 */
volatile unsigned char* trng_buffer(void)
{
	return buffer;
}

/**
 * @brief Returns a pointer to the internal TRNG buffer.
 *
 * @details
 * This function provides direct access to the internal memory buffer that stores the corrected random bytes generated by the True Random Number Generator (TRNG). The buffer can be read once the buffer status, retrieved by @ref trng_buffer_status(), indicates that it is full.
 *
 * @return volatile unsigned char*: Pointer to the internal TRNG buffer containing random data.
 *
 * @note
 * - The returned pointer references volatile memory, as the buffer content may be modified by ongoing TRNG operations.
 * - Ensure that the buffer is not read while still filling to avoid inconsistent data.
 *
 * @see trng_buffer_status(), trng_reset()
 */
void trng_reset(void)
{
	for (unsigned char i=0; i < TRNG_BUFFER_SIZE; i++)
	{
		buffer[i] = 0x00;
	}
	current_buffer_position = 0;
	current_buffer_bit_position = 0;

	first_bit = 0;
	last_bit = 0;
	primary_run = 0;
}


